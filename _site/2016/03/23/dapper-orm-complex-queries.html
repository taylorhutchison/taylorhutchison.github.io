<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Creating complex objects with Dapper</title>
  <meta name="description" content="Intro">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/2016/03/23/dapper-orm-complex-queries.html">
  <link rel="alternate" type="application/rss+xml" title="Programming for Joy" href="http://localhost:4000/feed.xml">
</head>


  <body>

    
  <header class="container">
    <div>
      <a href="/">Programming for Joy</a>
      <nav>
        
        
        <a href="/about/">About</a>
        
        
        
        
        
        
        
        
      </nav>
    </div>
  </header>


    <div>
      <div>
        <main class="container">
    <article itemscope itemtype="http://schema.org/BlogPosting">

        <header>
            <h1 itemprop="name headline">Creating complex objects with Dapper</h1>
            <p>
                
                <time datetime="2016-03-23T18:00:00-05:00" itemprop="datePublished">Mar
                    23, 2016</time>
                
            </p>

        </header>

        <div itemprop="articleBody">
            <h3 id="intro">Intro</h3>

<p>Dapper for .NET is a great tool if you want something between pure ADO.NET and a large ORM like Entity Framework or NHibernate. If you still need the control that hand-writing your SQL queries provides, but want a cleaner way of populating your objects with the records then I suggest you check out a micro-ORM like Dapper.</p>

<p>Dapper is very straight-forward when you want to fill up an object or list of objects where the class is composed of simple types (int, string, etc.), but becomes a bit more complex when classes are composed of object hierarchies (i.e. a Person class has an Address class property). So in this post I’m going to discus the basics of how you could approach this problem.</p>

<h3 id="setup">Setup</h3>

<p>Lets say your data looked like this:</p>

<h4 id="people-table">People Table</h4>

<table>
  <thead>
    <tr>
      <th>Id</th>
      <th>FirstName</th>
      <th>LastName</th>
      <th>AddressId</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Amber</td>
      <td>Johnson</td>
      <td>77</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Bill</td>
      <td>Smith</td>
      <td>56</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Chris</td>
      <td>Davidson</td>
      <td>34</td>
    </tr>
  </tbody>
</table>

<h4 id="addresses-table">Addresses Table</h4>

<table>
  <thead>
    <tr>
      <th>Id</th>
      <th>StreetNumber</th>
      <th>StreetName</th>
      <th>City</th>
      <th>State</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>34</td>
      <td>1234</td>
      <td>College St</td>
      <td>Lansing</td>
      <td>MI</td>
    </tr>
    <tr>
      <td>56</td>
      <td>5555</td>
      <td>Nice Ave</td>
      <td>Nashville</td>
      <td>TN</td>
    </tr>
    <tr>
      <td>77</td>
      <td>9876</td>
      <td>Winding Way</td>
      <td>Boulder</td>
      <td>CO</td>
    </tr>
  </tbody>
</table>

<p>And our class definitions look like this:</p>

<h4 id="person-class">Person Class</h4>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="n">Address</span> <span class="n">Address</span><span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h4 id="address-class">Address Class</h4>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">Address</span> <span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">StreetNumber</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">StreetName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">City</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">State</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h3 id="basic-queries">Basic Queries</h3>

<p>We could create a List of type Person using the Dapper Query extension method. That would look like this:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="n">db</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">&gt;(</span><span class="s">"SELECT * FROM People"</span><span class="p">).</span><span class="nf">ToList</span><span class="p">();</span></code></pre></figure>

<p>That code assumes you have an object called db that is an instance of something implementing IDbConnection (e.g. SqlConnection in the System.Data.SqlClient namespace.) Similarily if we wanted to create a List of type Address we could write this:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp">    <span class="n">db</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Address</span><span class="p">&gt;(</span><span class="s">"SELECT * FROM ADDRESSES"</span><span class="p">).</span><span class="nf">ToList</span><span class="p">();</span></code></pre></figure>

<h3 id="complex-queries">Complex Queries</h3>

<p>The queries above show just how simple it can be to use Dapper on flat objects. However, what if you wanted to have the Address property on a Person instance be populated with data as a result of a JOIN. It’s possible to fill up a List of Persons and a List of Addresses and then find matches using LINQ, but why not let do it all in a single query and let Dapper handle the details.</p>

<p>So lets say our query was this:</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql">   <span class="k">SELECT</span> 
    <span class="n">P</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">LastName</span><span class="p">,</span> 
    <span class="n">A</span><span class="p">.</span><span class="n">Id</span> <span class="k">AS</span> <span class="n">AddressId</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">StreetNumber</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">StreetName</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">City</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="k">State</span> 
    <span class="k">FROM</span> <span class="n">People</span> <span class="n">P</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">Addresses</span> <span class="n">A</span> <span class="k">ON</span> <span class="n">A</span><span class="p">.</span><span class="n">AddressId</span> <span class="o">=</span> <span class="n">P</span><span class="p">.</span><span class="n">AddressId</span><span class="p">;</span></code></pre></figure>

<p>We would expect our results table to look like this:</p>

<table>
  <thead>
    <tr>
      <th>Id</th>
      <th>FirstName</th>
      <th>LastName</th>
      <th>StreetNumber</th>
      <th>AddressId</th>
      <th>StreetName</th>
      <th>City</th>
      <th>State</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Amber</td>
      <td>Johnson</td>
      <td>1234</td>
      <td>77</td>
      <td>Winding Way</td>
      <td>Boulder</td>
      <td>CO</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Bill</td>
      <td>Smith</td>
      <td>5555</td>
      <td>56</td>
      <td>Nice Ave</td>
      <td>Nashville</td>
      <td>TN</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Chris</td>
      <td>Davidson</td>
      <td>9876</td>
      <td>34</td>
      <td>College St</td>
      <td>Lansing</td>
      <td>MI</td>
    </tr>
  </tbody>
</table>

<p>We could create a List of type Person with the Address property filled with the results like this:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="kt">var</span> <span class="n">sql</span> <span class="p">=</span> <span class="s">"SELECT P.Id, P.FirstName, P.LastName, "</span> <span class="p">+</span>
    <span class="s">"A.Id AS AddressId, A.StreetNumber, A.StreetName, A.City, A.State "</span> <span class="p">+</span>
    <span class="s">"FROM People P INNER JOIN Addresses A ON A.AddressId = P.AddressId; "</span><span class="p">;</span>

<span class="n">db</span><span class="p">.</span><span class="n">Query</span><span class="p">&lt;</span><span class="n">Person</span><span class="p">,</span> <span class="n">Address</span><span class="p">,</span> <span class="n">Person</span><span class="p">&gt;(</span>
<span class="n">sql</span><span class="p">,</span> 
<span class="p">(</span><span class="n">person</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="n">person</span><span class="p">.</span><span class="n">Address</span> <span class="p">=</span> <span class="n">address</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">person</span><span class="p">;</span>
<span class="p">},</span>
<span class="n">splitOn</span><span class="p">:</span> <span class="s">"AddressId"</span>
<span class="p">).</span><span class="nf">ToList</span><span class="p">();</span>
   </code></pre></figure>

<p>Three important things to point out in the code above:</p>

<p>1) The Query generic parameter is not taking a single type but rather a Func&lt;&gt;. So a Func&lt;Person, Address, Person&gt; will take a Person and an Address object as parameters and return a object of type Person.</p>

<p>2) The magic is happening down in the lambda where we just have to tell the new address object (created by Dapper) where to go. In this case its a property on the newly instantiated person object (also created by Dapper).</p>

<p>3) In order to make this happen we have to use the “splitOn” parameter in the Query function. splitOn tells Dapper which column in the records represents the start of the second object. Since AddressId is the first column that is part of the Address object and not the Person object, thats where we want to “split on”.</p>

<h3 id="conclusion">Conclusion</h3>
<p>Dapper makes it incredibly easy to go from the relational world to the object-oriented world while still maintaining the power and flexibility that hand-rolling your queries affords.</p>

<p>Creating object hierarchies from simple queries is only a little more difficult than creating a single object. You only need to provide Dapper some clues about where things go and let it handle the rest.</p>

        </div>

    </article>
</main>
      </div>
    </div>

    
<footer class="container">



    <div>
      <div>
        <ul>
          <li><a href="mailto:seanthutchison@gmail.com">seanthutchison@gmail.com</a></li>
        </ul>
      </div>

      <div>
        <ul>
          
          <li>
            <a href="https://github.com/taylorhutchison"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">taylorhutchison</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/taylorhutchison"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">taylorhutchison</span></a>

          </li>
          
        </ul>
      </div>

    </div>


</footer>


  </body>

</html>